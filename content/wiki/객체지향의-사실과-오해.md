---
title: "객체지향의-사실과-오해"
summary: ""
layout: wiki
parent: 
tags: []
toc: true
latex: false
date: 2020-07-27T12:56:05+0900
lastmod: 2020-07-27T12:56:05+0900
---

## 1장 협력하는 객체들의 공동체
객체지향에서 중요한 세가지 개념: 역할, 책임, 협력

- 요청을 하고 응답을 하고...: 협력
- 협력을 하기 위해서는 역할이 있어야. 그런데 역할은 곧 책임을 내포
  - 여러 사람이 동일한 역할을 수행 가능
  - 역할은 대체 가능성(같은 역할을 지닌 다른 사람으로)
  - 책임을 수행하는 법은 자율적으로. 알아서 역할만 수행하면.: polymorphism
  - 한 사람이 동시에 여러 역할을 수행할 수 있음: 여러 interface implemets

### 객체지향 프로그램에는 객체가 한다.
- 객체는 서로 메시지를 주고받으며 협력
- 객체의 미덕:
  - 객체는 충분히 협력적이어야. 다른 객체의 요청에 귀기울이고 도움을 요청할 수 있어야 한다.
  - 객체는 충분히 자율적이어야.

객체지향에서 중요한건 클래스가 아니라(물론 중유하지만...) 책임, 역할, 협력이다.

## 2장 이상한 나라의 객체
- 원래 사람은 객체를 이용해 본다?
  - 세상살이의 복잡성을 줄이기 위해.
  - 길, 길가는 자동차, 태양...
- 객체지향 패러다임의 목적은 현실세계를 모방하는 것이 아니라 현실세계를 기반으로 새로운 세계를 만드는 것

객체는 상태, 생동, 식별자를 가진다

> 객체란 식별 가능한 개체 또는 사물이가다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.
> p.47

### 상태
#### 왜 필요한가
- 객체가 주변 환경과 상호작용하면서 어떻게 변하는가.
- 어떤 행동의 결과는 과거에 어떤 행동들이 일어났는가에 의존.
- 그런데 과거의 행동을 모두 기억하는 것은 힘들다.
- 따라서 과거 행동들의 과정과 결과를 단순하게 기술하기 위해 상태라는 개념을 고안.

#### 상태와 프로퍼티
- 세상의 모든 것이 객체인것은 아니다.
- 예를들어 앨리스의 키, 음료의 양 같은 것.
- 이것들은 독립적이기보다 다른 객체의 특성, 즉 상태를 표현하는데 사용.
- 또 때로는 상태를 표현하기 위해 다른 객체를 사용할 때도 있다.
- 일반적으로 프로퍼티(앨리스의 경우 키, 위치 등)은 정적이다.
- 반면 property value(앨리스의 키 값, 위치 값)등은 동적
- 객체와 객체 사이의 의미있는 연결을 링크(link)라고 하자
- 객체 사이에는 링크를 통해서만 메시지를 주고받을 수 있다.

> 생태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 독적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값(속성, attribute)와 다른 객체를 참조하는 링크로 구분할 수 있다.
> p.51

- 객체는 자율적이다. 그리고 자신의 상태에 칙임을 져야 한다. 객체가 다른 객체의 상태를 직접 주무를 수 없다.

### 행동
- 객체가 행동을 하면 상태가 변한다. 즉 side effect를 초래.
	- 객체의 행동은 상태에 영향을 받는다.(키큰 앨리스는 문을 통과할 수 없다.)
	- 객체의 행동은 상태를 변경시킨다.(음료를 마시면 앨리스틑 커진다.)
> 행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 ㅊ객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.
> p.55

- 상태를 캡슐화 해야한다.
  - 앨리스가 을료수를 마실 때 쓰는 `drinkBeberage()`를 보고 앨리스의 키가 바뀐다고 유추할 수 없다.

### 식별자
- 값은 immutable하다. 즉 두개가 같으면 같다.
- 객체는 시간에 따라 변경되는 상태를 포함하며 행동은 상태를 변경한다. 즉 객체는 mutable state를 가진다고 할 수 있다.
- 두개 객체는 같아도 다르고 달라도 같을 수 있다.
  - 어제의 나와 오늘의 나의 상태는 다르지만 같은 객체이다.
  - 반대로 복제인간은 상태는 같지만 다른 객체이다.
- 그래서 객체에게는 동일성을 판단할 수 있는 식별자가 필요하다.

> 식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.
> p.58

### 행동이 상태를 결정한다.
- 객체를 만들 때 상태를 먼저 결정하면
  1. 캡슐화가 저해된다. 생태가 객체 내부로 갭술화되지 못하고 공용 인터페이스에 그대로 노출되기 십상이다.
  1. 객체를 협력자가 아닌 고립된 섬으로 만든다.
  1. 객체의 재사용성이 저하된다. 상태에 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵기 때문
- 그래서 인터페이스 기반의 프로그램을 만들어야 한다.

## 3장 타입과 추상화
- 세상은 복잡하기 때문에 추상화시켜 좀 더 단순하게 살아보자
- 지하철 노선도를 보면 지형같은 쓸데 없는/관심 없는 것은 배제하고 필요한 것만 있다: 추상화
- 현실 세계와 물리적 모델링
  - 공던지기 포물선 문제: 공의 색이나 저항은 무시하자
- 그룹으로 나누어 단순화시키기
  - 농구공, 축구공, 배구공들을 공으로 퉁치자.
  - 나, 너, 김씨, 박씨, 이씨를 사람으로 퉁치자.
- 어떻게 퉁칠수 있을까?
- 공통된 부분이 있고 우리의 관심사는 공통된 부분이기 때문에.

- 객체들을 추상화해서(부분을 잘 무시해서) 하나로 퉁친 것을 개념(concept)이라고 부르자.

> 객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.
> p.84

### 개념의 세 가지 관점
- 심볼: 개념을 가르키는 이름
- 내연(intension): 개념의 정의. "행성은 항성을 도는 것"
- 외연(extension): 개념에 속하는 모든 객체의 집합. "지구는 행성."

- 어떤 객체를 어떤 개념에 적용할지 정하는 건 중요한 일. 이를 분류라고 하다.

### 타입
- 개념의 있어보이는 말, "타입"
- 프로그램의 관점에서 타입은 0과 1의 배열을 어떻게 해석할 지
  - 타입에 따라 적용할 수 있는 operator가 다르다.
  -보면  타입으로 가리면 뒤쪽의 0과 1은 안보인다.

### 객체와 타입
- 객체는 데이터인가: ㄴㄴ
- 객체에서 중요한 것은 객체의 행동. 상태는 부수효과를 처리하기 위해 도입한 개념.
- "책임, 역할, 협력" 중에 상태는 없다.

1. 어떤 객체가 어떤 타입에 속하는지 결정하는 것은 객체가 하는 행동.
1. 객체 내부는 밖에서 안보인다.
  - 자판기 안에서 사람이 커피타도 ㄱㅊ

다시한번 말한다; 객체의 타입은 행동에 의해 결정된다.

### 타입의 계층
- 타입에도 계층관계가 있다.
- 머그컵은 컵이다. 그런데 손잡이로 잡을 수 있는.
- 머그컵의 외연은 컵의 외연의 부분집합니다.
- 이 둘의 관계를 일반화/특수화(generalization/specialization) 관계라고 하자.
- 타입의 단어로는 supertype/subtype.
- 다시한번 말한다; 객체의 타입은 행동에 의해 결정된다.
  - 둘의 관계는 행동에 의해 결정된다.
  - 수퍼타입이 할 수 있는 것은 서브타입도 할 수 있다:
  - 교체할 수 있다.

### 정적타입
- 그래서 왜 타입이 필요할까?
- 바뀌는 것을 생각하기에는 너무 힘들다.
- 안바뀌는 것을 생각하는 것은 좀 더 쉽다.
- 바뀌는 객체(1m의 앨리스, 4m의 앨리스...)를 정적인 모습(키가 있는 앨리스)로 추상화하자.
- 그렇다. 타입은 객체의 상태변화라는 요소를 제거하고 정적으로 추상화 한 것이다.

#### 동적 모델과 정적 모델
- 객체를 생각할 때 상태가 바뀌는 스냅샷으로 생각하던가
- 시간에 독립적인 정적 모델로 생각하던가.
- 애플리케이션을 만들기 위해서는 둘을 섞어써야한다.

#### 클래스
- 타입을 구현하는 가장 보편적인 방법은 클래스
- 주의: **구현하는**. 클래스는 타입이 아니다. JS에서는 프로토타입 기반
