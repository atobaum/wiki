<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Atobaum Wiki</title><link rel=stylesheet href=https://atobaum.github.io/css/index.css><link rel=stylesheet href=https://atobaum.github.io/css/reset.css><link rel=apple-touch-icon sizes=180x180 href=https://atobaum.github.io/fav/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://atobaum.github.io/fav/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://atobaum.github.io/fav/favicon-16x16.png><link rel=manifest href=https://atobaum.github.io/fav/site.webmanifest><script async src="https://www.googletagmanager.com/gtag/js?id=UA-177439615-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-177439615-1');</script></head><body><div id=wrap><header id=gheader><div class="flex flex-jsb"><div id=logo><a href=https://atobaum.github.io>Atobaum Wiki</a></div><nav class=right0><ul id=gnb><li><a href=/about>about</a></li><li><a href=/>all</a></li><li><a href=/random>random</a></li><li><a href=/tags>tags</a></li></ul></nav></div><div id=search class=flex-end>searchbar</div></header><div id=main><h1 class=content-title>HTTP 완벽 가이드 정리</h1><h3 class=content-summary>&lt;HTTP 완벽 가이드 정리>를 대충 요약보았다.</h3><div><div><ul class=tag-list><li class=tag><a href=https://atobaum.github.io/tags/http>#HTTP</a></li><li class=tag><a href=https://atobaum.github.io/tags/book>#Book</a></li><li class=tag><a href=https://atobaum.github.io/tags/summary>#Summary</a></li></ul></div><div class=content-meta><ul><li>작성: 2020-07-27<li></li>수정: 2020-07-27</li></ul>4 분 걸려요.</div><div><aside id=toc-wrapper><nav id=TableOfContents><ul><li><a href=#1장>1장</a></li><li><a href=#2장-url과-리소스>2장 URL과 리소스</a></li><li><a href=#4장-커넥션-관리>4장 커넥션 관리</a><ul><li><a href=#tcp-성능>TCP 성능</a></li><li><a href=#http-커넥션-관리>HTTP 커넥션 관리</a><ul><li><a href=#parallel-connection>Parallel connection</a></li><li><a href=#persistent-connection>Persistent connection</a></li><li><a href=#pipelined-connection>Pipelined connection</a></li></ul></li><li><a href=#어떻게-커넥션을-끊을까>어떻게 커넥션을 끊을까</a></li></ul></li><li><a href=#7장-캐시>7장 캐시</a><ul><li><a href=#캐시-토폴로지>캐시 토폴로지</a></li><li><a href=#캐시-처리-단계>캐시 처리 단계</a></li><li><a href=#신선한-사본>신선한 사본</a></li><li><a href=#캐시제어>캐시제어</a></li><li><a href=#서버가-알려주지-않을-때>서버가 알려주지 않을 때</a></li><li><a href=#클라이언트-신손도-제약>클라이언트 신손도 제약</a></li></ul></li></ul></nav></aside><article class=content-article><h1 id=1장>1장</h1><p>HTTP는 단순한 문자열. 요청, 헤더, 본문으로 이루어짐.</p><p>HTTP는 tcp로 전달됨(3은 udp쓴다던데&mldr;)
tcp는</p><ul><li>오류 없는 데이터 전송</li><li>순서에 맞는 전달</li><li>조각 나지 않는 데이터 스트림
을 제공한다.</li></ul><p>telnet으로 HTTP 요청을 해보자</p><div class=highlight><pre style=color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ telnet www.google.com <span style=color:#2aa198;font-weight:700>80</span>
GET / HTTP/1.1
HOST: www.google.com
</code></pre></div><p>웹 애플리케이션 중 특이한 사람들:</p><ul><li>프락시</li><li>캐시</li><li>게이트웨이</li><li>터널</li><li>에이전트
자세한건 후술.</li></ul><h1 id=2장-url과-리소스>2장 URL과 리소스</h1><p>헤더는 CRLF로 줄바꿈. body가 없어도 빈줄(CRLF)로 끝나야한다.</p><h1 id=4장-커넥션-관리>4장 커넥션 관리</h1><ul><li>HTTP는 TCP/IP를 이용.</li><li>HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향르 받는다.</li></ul><h2 id=tcp-성능>TCP 성능</h2><ul><li>HTTP 트랜잭션을 처리하는 시간보다 TCP 연결 설정, 요청, 응답메시지 전송이 더 오래걸린다.</li><li>TCP는 비싸다. 대부분의 HTTP 지연은 TCP 지연때문에 발생</li></ul><ol><li>TCP 연결 핸드셰이크 지연</li><li>확인 응답 지연: tcp 패킷의 확인 응답은 크기가 작아서 같은 곳으로 송출되는 패킷에 편승 시키는데 요청과 응답으로만 이루어지는 http 동작 방식은 기회를 감소시킨다.</li><li>TCP slow start: tcp 연결이 만들어 진 후 시간이 지나면서 최대 속도제한이 늘어난다. 다른말로 초반에는 느리다.</li><li>네이글 알고리즘: 크기가 작은 테이터는 한데 모아서 보낸다.</li></ol><h2 id=http-커넥션-관리>HTTP 커넥션 관리</h2><p>어떻게 하면 HTTP 커넥션 성능을 향상시킬 수 있을 까?</p><h3 id=parallel-connection>Parallel connection</h3><p>여러 커넥션으로 한꺼번에 처리. 그러나 대역폭이 충분하지 않으면 효과가 없고 오히려 관리비용때문에 느려질 수도 있다.
브라우저는보총 적은 수(6-8개)의 커넥션을 사용한다.</p><h3 id=persistent-connection>Persistent connection</h3><p>한 페이지에 있는 링크들은 대부분 같은 서버에 있다. TCP 연결을 일회용으로 쓰지 않고 재사용. TCP 연결 지연 시간을 줄일 수 있다. 게다가 tcp의 느린 시작으로 인한 지연도 줄일 수 있다.</p><p>keep-alive 헤더는 HTTP/1.1에서는 빠졌다. 그러나 아직 사용되고 있다. (HTTP/1.1에서는 지속 커넥션이 기본). 그러나 연결을 보장하지는 않는다. 누군가 언제든지 연결을 끊을 수 있음.</p><p>중간에 프록시 서버가 있으면 문제가 생길 수 있다. 만약 프록시가 헤더를 살펴보지 않고 그냥 전달만 한다면 클라이언트와 서버는 각각 프록시와 연결이 지속될거라고 기대하는데 프록시는 양쪽과 연결을 끊어버린다. 이를 피하기 위해 중계 서버를 통해 이뤄질 경우 클라이언트는 Proxy-Connection 헤더를 사용하기도 한다. 만약 프록시가 멍청하다면 서버는 Connection 헤더가 없어서 연결을 끊고 프록시가 똑똑하면 Proxy-Connection을 Connection으로 바꿔보내고 연결을 유지한다.</p><p>HTTP/1.1에서는 별도 설정을 하지 않는 한 모든 커넥션을 지속 커넥션으로 간주. HTTP/1.1 어플리케이션은 Connection: close를 명시해야한다.</p><h3 id=pipelined-connection>Pipelined connection</h3><p>한 커넥션에서 응답이 도착하기 전에 요청을 보내기.</p><ul><li>지속 커넥션에서만 이용해야한다.</li><li>HTTP 메시지는 순번이 정해져있지 않아 요청 순서과 똑같이 응답이 와야한다.</li><li>HTTP 클라이언트는 커넥션이 언제 끊어지더라도 완료되지 않은 요청이 있으면 요청을 다시 보낼 준비가 되어있어야. 서버가 반만 보내고 연결 끊을 수도.</li><li><strong>POST와 같이 반복해서 보낼 경우 문제가 생기는 요청은 보내면 안된다.</strong></li></ul><h2 id=어떻게-커넥션을-끊을까>어떻게 커넥션을 끊을까</h2><ul><li><p>마음대로 끊기
주의: 몇번 실행됬는지에 상관 없이 결과가 같다면 멱등(idempotent)하다고 한다. GET, HEAD, PUT, DELETE 같은거. 그런데 POST 같이 멱등이 아닌 요청은 파이프라인을 통해 보내면 안된다.</p></li><li><p>우아하게 끊기
먼저 반만(출력체널)만 끊고 입력이 끊어지기를 기다릴 수도 있다.</p></li></ul><h1 id=7장-캐시>7장 캐시</h1><p>캐시는 무엇을 해결할까:</p><ul><li>불필요한 데이터 전송</li><li>대역폭 병목</li><li>갑작스런 요청 쇄도</li><li>거리로 인한 지연</li></ul><p>캐시는 무슨 문제가 있을까:</p><ul><li>캐시가 최신 정보인지 확인이 필요</li></ul><p>문제를 어떻게 해결할까:</p><ul><li>재검사(revalidation): 여러가지 방법이 있다. 예를들어 서버에 요청을 보내지만 If-Modified-Since 헤더를 이용. 안바뀌었으면 304 Not Modified 응답을 보낸다.</li></ul><h2 id=캐시-토폴로지>캐시 토폴로지</h2><ul><li>개인 전용 캐시: 예를 들어 브라우저 내장 캐시</li><li>공용 프락시 캐시</li><li>프락시 캐시에도 계층이 있을 수 있다.</li></ul><h2 id=캐시-처리-단계>캐시 처리 단계</h2><ol><li>요청 받기</li><li>파싱: 캐시가 요청에서 URL과 헤더들을 추출</li><li>검색: 가지고 있는가?</li><li>신선도 검사: 가지고 있으면 신선한지 (잘) 검사</li><li>응답 생성</li><li>발송</li><li>로깅</li></ol><h2 id=신선한-사본>신선한 사본</h2><p>HTTP는 Cache-Control과 Expires라는 헤더를 이용해 원 서버가 리소스에 유휴기간을 붙일 수 있도록 해준다.</p><pre><code>Cache-Control: max-age=484200
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
</code></pre><p>Cache-Control: max-age는 남은 시간을 초로 지정. Expires는 유효기간은 GMT로 지정
만약 캐시 서버의 시간이 동기화되있지 않으면 Expires는 잘 작동을 안 할 수도 있다.</p><p>또는 ETag 사용: 주석 추가 같은 다르지만 같은 리소스나 최근 변경 일시를 정확하게 판별할 수 없거나 1초의 정밀도가 충분하지 않을 떄.</p><h2 id=캐시제어>캐시제어</h2><ul><li>Cache-Control: no-store: 리소스의 사본을 만드는 것을 금지. 개인정보가 들어있거나.</li><li>Cache-Control: no-cache: 로컬 캐시 저장소에 저장될 수 있음. 다만 서버와 재검사 필수.</li><li>Cache-Control: must-revalidate: 캐시는 성능 개선을 위해 만료된 객체를 제공할 수 있다. 이 헤더를 설정하면 ㅇ만료된 객체를 재검사 없이 재공해서는 안된다.</li></ul><h2 id=서버가-알려주지-않을-때>서버가 알려주지 않을 때</h2><p>캐시 서버는 알아서 추측한다. 예를들어</p><ul><li>마지막 변경일이 오래됬다면 안정적인 문서로 예측, vice versa.</li></ul><h2 id=클라이언트-신손도-제약>클라이언트 신손도 제약</h2><ul><li>Cache-Control: max-stale: 신선하지 않아도 된다.</li><li>Cache-Control: min-fresh = &lt;s>: 만료기간이 s초 이상 남아야 한다.</li><li>등등</li></ul></article></div></div></body></html>